namespace std::prelude;
    let true: bool = "" == "";
    let false: bool = !true;

namespace std::check;
    /// This is a built-in function taking a string argument and terminating
    /// evaluation unsuccessfully with this argument as explanation.
    /// This symbol is not an empty array, the actual semantics are overridden.
    let panic: string -> ! = [];

    /// Checks the condition and panics if it is false.
    /// IMPORTANT: Since this does not generate any constraints, the verifier will not
    /// check these assertions. This function should only be used to verify
    /// prover-internal consistency.
    /// The panic message is obtained by calling the function `reason`.
    /// Returns an empty array on success, which allows it to be used at statement level.
    let assert: bool, (-> string) -> () = |condition, reason| if !condition { panic(reason()) } else { () };

namespace std::prover;
    /// Returns the current number of rows, sometimes known as the "degree".
    let degree: -> int = [];

namespace std::utils;
    /// Evaluates to folder(...folder(folder(initial, f(0)), f(1)) ..., f(length - 1)),
    /// i.e. calls f(0), f(1), ..., f(length - 1) and combines the results
    /// using the function `folder`, starting with the value `initial`.
    ///
    /// See `sum` for an example use.
    let<T1, T2>
        fold: int, (int -> T1), T2, (T2, T1 -> T2) -> T2 = |length, f, initial, folder|
            if length <= 0 {
                initial
            } else {
                folder(fold((length - 1), f, initial, folder), f((length - 1)))
            };

namespace std::array;
    /// This is a built-in function taking an array argument and returning
    /// the length of the array.
    /// This symbol is not an empty array, the actual semantics are overridden.
    let<T> len: T[] -> int = [];

    /// Evaluates to the array [f(0), f(1), ..., f(length - 1)].
    let<T> new: int, (int -> T) -> T[] = |length, f| std::utils::fold(length, f, [], |acc, e| (acc + [e]));

    /// Returns a new array equal to arr except that the element at index i is x.
    let<T> set_element: T[], int, T -> T[] = |arr, i, x| {
        let _ = std::check::assert(i < len(arr), || "Index out of bounds");
        map_enumerated(arr, |j, y| if i == j { x } else { y })
    };

    /// Returns a new array of length l containing the elements of arr starting at index start.
    let<T> sub_array: T[], int, int -> T[] = |arr, start, l| std::array::new(l, |i| arr[start + i]);

    /// Evaluates to the array [f(arr[0]), f(arr[1]), ..., f(arr[len(arr) - 1])].
    let<T1, T2> map: T1[], (T1 -> T2) -> T2[] = |arr, f| new(len(arr), |i| f(arr[i]));

    /// Evaluates to the array [f(0, arr[0]), f(1, arr[1]), ..., f(len(arr) - 1, arr[len(arr) - 1])].
    let<T1, T2> map_enumerated: T1[], (int, T1 -> T2) -> T2[] = |arr, f| new(len(arr), |i| f(i, arr[i]));

    /// Computes folder(...folder(folder(initial, arr[0]), arr[1]) ..., arr[len(arr) - 1])
    let<T1, T2> fold: T1[], T2, (T2, T1 -> T2) -> T2 = |arr, initial, folder| std::utils::fold(len(arr), |i| arr[i], initial, folder);

    /// Returns the sum of the array elements.
    // TODO: Should make use of the Default or Zero trait instead of FromLiteral (then we can also
    // use this function to flatten an array of arrays.
    let<T: Add + FromLiteral> sum: T[] -> T = |arr| fold(arr, 0, |a, b| a + b);

    /// Returns the product of the array elements.
    let<T: Mul + FromLiteral> product: T[] -> T = |arr| fold(arr, 1, |a, b| a * b);

    /// Zips two arrays
    /// TODO: Assert that lengths are equal when expressions are supported.
    let<T1, T2, T3> zip: T1[], T2[], (T1, T2 -> T3) -> T3[] = |array1, array2, fn| new(len(array1), |i| fn(array1[i], array2[i]));

namespace Main(8);

    // A ArrayTerm in an `ArrayExpression`
    enum ArrayTerm {
        Repeat(int[]),
        Once(int[])
    }

    // returns the total size of the repeated array in this `ArrayExpression`
    let solve: ArrayTerm[] -> int = |terms| {
        let (_, total_size_of_non_repeated) = std::array::fold(terms, (std::prelude::false, 0), |(found_repeated, len), ArrayTerm| {
            match ArrayTerm {
                // we can have `[]*` as many times as we want
                ArrayTerm::Repeat([]) => (found_repeated, len),
                ArrayTerm::Repeat(a) => {
                    if found_repeated {
                        std::check::panic("unsolvable because two terms are repeated");
                        (found_repeated, 42)
                    } else {
                        (std::prelude::true, len)
                    }
                },
                ArrayTerm::Once(a) => (found_repeated, len + std::array::len(a))
            }
        });
        if total_size_of_non_repeated > std::prover::degree() {
            std::check::panic("non repeated array terms do not fit in degree");
            42
        } else {
            std::prover::degree() - total_size_of_non_repeated
        }
    };

    /// repeat `repeated` until we reach a length of `total_len`, truncating
    let expand_to_len = |repeated, total_len|
        std::array::new(total_len, |j| repeated[j % std::array::len(repeated)]);

    // expand an `ArrayExpression` into a single complete array
    let expand: ArrayTerm[] -> int[] = |terms| {
        // get the total size of the repeated ArrayTerm
        let size_of_repeated = solve(terms);
        let terms_expanded = std::array::map(terms, |ArrayTerm| {
            match ArrayTerm {
                // expand the repeated ArrayTerm
                ArrayTerm::Repeat(a) => expand_to_len(a, size_of_repeated),
                // return other terms
                ArrayTerm::Once(a) => a,
            }
        });
        // concatenate all expanded terms
        std::array::fold(terms_expanded, [], |acc, ArrayTerm| acc + ArrayTerm)
    };

    let repeat: int[] -> ArrayTerm = |a| ArrayTerm::Repeat(a);

    let once: int[] -> ArrayTerm = |a| ArrayTerm::Once(a);

    // test utility
    let assert_eq: expr, expr -> () = constr |left, right| {
        let diff;
        diff = left - right;
        diff = 0;
    };

    // let F0 = [1, 2, 3]* + [1] + [1, 2, 3, 1];
    let r0 = expand([repeat([1, 2, 3]), once([1]), once([1, 2, 3, 1])]);
    col fixed res0(i) { r0[i] };
    col fixed expected0 = [1, 2, 3, 1, 1, 2, 3, 1];
    assert_eq(res0, expected0);

    // let F1 = [1, 2]*;
    let r1 = expand([repeat([1, 2])]);
    col fixed res1(i) { r1[i] };
    col fixed expected1 = [1, 2, 1, 2, 1, 2, 1, 2];
    assert_eq(res1, expected1);

    // let F2 = [1, 2] + [1, 2, 1, 2, 1, 2];
    let r2 = expand([once([1, 2]), once([1, 2, 1, 2, 1, 2])]);
    col fixed res2(i) { r2[i] };
    col fixed expected2 = [1, 2, 1, 2, 1, 2, 1, 2];
    assert_eq(res2, expected2);

    // let F3 = []* + [1, 2, 1, 2, 1, 2, 3, 4];
    let r3 = expand([repeat([]), once([1, 2, 1, 2, 1, 2, 3, 4])]);
    col fixed res3(i) { r3[i] };
    col fixed expected3 = [1, 2, 1, 2, 1, 2, 3, 4];
    assert_eq(res3, expected3);

    // let F4 = []* + [1, 2, 1, 2] + [1]*;
    let r4 = expand([once([1, 2, 1, 2]), repeat([1])]);
    col fixed res4(i) { r4[i] };
    col fixed expected4 = [1, 2, 1, 2, 1, 1, 1, 1];
    assert_eq(res4, expected4);

    // let F5 = [1]* + [1]*; // should panic
    let r5 = expand([repeat([1]), repeat([1])]);
    // col fixed res5(i) { r5[i] }; // uncomment this line to panic
